---
const PAGE_TITLE_ID = '_top';
const { data } = Astro.locals.starlightRoute.entry;
const { title = data.title, tagline, actions = [] } = data.hero || {};
---

<div class="hero">
	<!-- Dial Container - Inside hero for proper scoping -->
	<div class="dial-container" id="dial-container">
		<!-- SVG injected by JS -->
	</div>

	<!-- Hero Content -->
	<div class="hero-content">
		<div class="sl-flex stack">
			<div class="sl-flex copy">
				<h1 id={PAGE_TITLE_ID} data-page-title set:html={title} />
				{tagline && <div class="tagline" set:html={tagline} />}
			</div>
			{
				actions.length > 0 && (
					<div class="sl-flex actions">
						{actions.map(({ icon, link: href, text, variant }) => (
							<div class={`action-wrapper ${variant || 'primary'}`}>
								<a href={href} class={`action-link ${variant || 'primary'}`}>
									<span>{text}</span>
									{icon?.name === 'right-arrow' && (
										<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
											<path d="M5 12h14"></path>
											<path d="m12 5 7 7-7 7"></path>
										</svg>
									)}
									{icon?.name === 'external' && (
										<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
											<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
											<polyline points="15 3 21 3 21 9"></polyline>
											<line x1="10" y1="14" x2="21" y2="3"></line>
										</svg>
									)}
								</a>
							</div>
						))}
					</div>
				)
			}
		</div>
	</div>
</div>

<script>
	// Dial configuration
	const DIAL_COUNT = 5;
	const THUMB_RADIUS = 8;

	interface DialState {
		angle: number;
		direction: 1 | -1;
		baseSpeed: number;
		radius: number;
		dragging: boolean;
		hovered: boolean;
	}

	const dialStates: DialState[] = [];
	let svg: SVGSVGElement | null = null;

	// Smooth resize interpolation state
	let targetDimensions = { width: 0, height: 0 };
	let currentDimensions = { width: 0, height: 0 };
	let resizeFrame: number | null = null;

	function createDialGroup(
		index: number,
		centerX: number,
		centerY: number,
		radius: number,
		initialAngle: number
	): SVGGElement {
		const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
		group.classList.add('dial-group');
		group.dataset.index = String(index);
		group.style.transformOrigin = `${centerX}px ${centerY}px`;
		group.style.transform = `rotate(${initialAngle}deg)`;

		// Full circle track
		const track = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		track.classList.add('dial-track');
		track.setAttribute('cx', String(centerX));
		track.setAttribute('cy', String(centerY));
		track.setAttribute('r', String(radius));
		track.setAttribute('fill', 'none');
		track.setAttribute('stroke', '#84cc16');
		track.setAttribute('stroke-opacity', '0.1');
		track.setAttribute('stroke-width', '1.5');
		group.appendChild(track);

		// Invisible hit area (larger touch target)
		const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		hitArea.classList.add('dial-hit-area');
		hitArea.setAttribute('cx', String(centerX));
		hitArea.setAttribute('cy', String(radius));
		hitArea.setAttribute('r', String(THUMB_RADIUS * 2.5)); // Much larger hit area
		hitArea.setAttribute('fill', 'transparent');
		group.appendChild(hitArea);

		// Visible thumb at radius distance below pivot (cy=0)
		const thumb = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
		thumb.classList.add('dial-thumb');
		thumb.setAttribute('cx', String(centerX));
		thumb.setAttribute('cy', String(radius)); // radius below pivot
		thumb.setAttribute('r', String(THUMB_RADIUS));
		thumb.setAttribute('fill', '#0c0c0c');
		thumb.setAttribute('stroke', '#84cc16');
		thumb.setAttribute('stroke-width', '2');
		group.appendChild(thumb);

		return group;
	}

	function initDials() {
		const container = document.getElementById('dial-container') as HTMLElement;
		if (!container) return;

		const heroElement = document.querySelector('.hero') as HTMLElement;
		if (!heroElement) return;

		// Get hero's offset from page top (accounts for nav bar, etc.)
		const heroRect = heroElement.getBoundingClientRect();
		const scrollTop = window.scrollY || document.documentElement.scrollTop;
		const heroTopFromPage = heroRect.top + scrollTop;

		// Position container to start at page top
		container.style.top = `-${heroTopFromPage}px`;
		container.style.height = `${heroElement.offsetHeight + heroTopFromPage}px`;

		// Get or create SVG
		svg = container.querySelector('svg');
		if (!svg) {
			svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.style.cssText = `
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				overflow: visible;
			`;
			container.appendChild(svg);
		}

		// Clear existing content
		svg.innerHTML = '';
		dialStates.length = 0;

		const viewportWidth = window.innerWidth;
		const heroHeight = heroElement.offsetHeight;
		const totalHeight = heroHeight + heroTopFromPage;

		// Initialize dimensions for smooth resize
		if (currentDimensions.width === 0) {
			currentDimensions = { width: viewportWidth, height: totalHeight };
			targetDimensions = { width: viewportWidth, height: totalHeight };
		}

		// Update SVG viewBox - extends from page top through hero
		svg.setAttribute('viewBox', `0 0 ${viewportWidth} ${totalHeight}`);

		const centerX = viewportWidth / 2;
		const centerY = 0; // Pivot at absolute page top

		// Calculate radii - max radius = hero height (measured from page top)
		const maxRadius = heroHeight + heroTopFromPage;
		const minRadius = maxRadius / 6;
		const radiusStep = (maxRadius - minRadius) / (DIAL_COUNT - 1);

		for (let i = 0; i < DIAL_COUNT; i++) {
			const radius = maxRadius - i * radiusStep;

			// Initialize dial state with random starting position and speed
			const startAngle = Math.random() * 360;
			dialStates.push({
				angle: startAngle,
				direction: Math.random() > 0.5 ? 1 : -1,
				baseSpeed: 0.5 + Math.random() * 0.3, // Linear speed (pixels per frame conceptually)
				radius: radius,
				dragging: false,
				hovered: false,
			});

			// Create dial group with track and thumb
			const group = createDialGroup(i, centerX, centerY, radius, startAngle);
			svg.appendChild(group);

			// Setup drag handlers
			setupDragHandlers(group, i);
		}
	}

	function updateDialRotation(index: number, angle: number) {
		const group = document.querySelector(`.dial-group[data-index="${index}"]`) as SVGGElement;
		if (group) {
			group.style.transform = `rotate(${angle}deg)`;
		}
	}

	function updateDialDimensions(width: number, height: number) {
		if (!svg) return;

		svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

		const centerX = width / 2;
		const centerY = 0; // Pivot at page top
		// height is total height from page top through hero bottom
		const maxRadius = height;
		const minRadius = height / 6;
		const radiusStep = (maxRadius - minRadius) / (DIAL_COUNT - 1);

		for (let i = 0; i < DIAL_COUNT; i++) {
			const radius = maxRadius - i * radiusStep;
			const group = document.querySelector(`.dial-group[data-index="${i}"]`) as SVGGElement;
			if (!group) continue;

			// Update radius in state for animation normalization
			if (dialStates[i]) {
				dialStates[i].radius = radius;
			}

			// Update transform origin - pivot at page top center
			group.style.transformOrigin = `${centerX}px ${centerY}px`;

			// Update track
			const track = group.querySelector('.dial-track') as SVGCircleElement;
			if (track) {
				track.setAttribute('cx', String(centerX));
				track.setAttribute('cy', String(centerY));
				track.setAttribute('r', String(radius));
			}

			// Update thumb position (always at radius distance below center)
			const thumb = group.querySelector('.dial-thumb') as SVGCircleElement;
			if (thumb) {
				thumb.setAttribute('cx', String(centerX));
				thumb.setAttribute('cy', String(radius));
			}

			// Update hit area position
			const hitArea = group.querySelector('.dial-hit-area') as SVGCircleElement;
			if (hitArea) {
				hitArea.setAttribute('cx', String(centerX));
				hitArea.setAttribute('cy', String(radius));
			}
		}
	}

	function setupDragHandlers(group: SVGGElement, index: number) {
		const thumb = group.querySelector('.dial-thumb') as SVGCircleElement;
		const hitArea = group.querySelector('.dial-hit-area') as SVGCircleElement;
		if (!thumb || !hitArea) return;

		let isDragging = false;
		let angleOffset = 0;

		// Ensure touch-action is set inline for maximum compatibility
		hitArea.style.touchAction = 'none';

		const getAngleFromPoint = (clientX: number, clientY: number): number => {
			const centerX = window.innerWidth / 2;
			// Pivot at page top (y=0), in viewport coords that's -scrollY
			const centerY = -(window.scrollY || document.documentElement.scrollTop);
			const dx = clientX - centerX;
			const dy = clientY - centerY;
			return -Math.atan2(dx, dy) * (180 / Math.PI);
		};

		const startDrag = (clientX: number, clientY: number) => {
			isDragging = true;
			dialStates[index].dragging = true;
			thumb.classList.add('dragging');
			const cursorAngle = getAngleFromPoint(clientX, clientY);
			angleOffset = dialStates[index].angle - cursorAngle;
		};

		const moveDrag = (clientX: number, clientY: number) => {
			if (!isDragging) return;
			const cursorAngle = getAngleFromPoint(clientX, clientY);
			let newAngle = cursorAngle + angleOffset;
			while (newAngle < 0) newAngle += 360;
			while (newAngle >= 360) newAngle -= 360;
			dialStates[index].angle = newAngle;
			updateDialRotation(index, newAngle);
		};

		const endDrag = () => {
			if (!isDragging) return;
			isDragging = false;
			dialStates[index].dragging = false;
			thumb.classList.remove('dragging');
		};

		// Touch events for mobile (more reliable than pointer events on some devices)
		hitArea.addEventListener('touchstart', (e: TouchEvent) => {
			e.preventDefault();
			e.stopPropagation();
			const touch = e.touches[0];
			startDrag(touch.clientX, touch.clientY);
		}, { passive: false });

		document.addEventListener('touchmove', (e: TouchEvent) => {
			if (!isDragging) return;
			e.preventDefault();
			const touch = e.touches[0];
			moveDrag(touch.clientX, touch.clientY);
		}, { passive: false });

		document.addEventListener('touchend', () => {
			endDrag();
		});

		document.addEventListener('touchcancel', () => {
			endDrag();
		});

		// Mouse events for desktop
		hitArea.addEventListener('mousedown', (e: MouseEvent) => {
			e.preventDefault();
			e.stopPropagation();
			startDrag(e.clientX, e.clientY);
		});

		document.addEventListener('mousemove', (e: MouseEvent) => {
			if (!isDragging) return;
			moveDrag(e.clientX, e.clientY);
		});

		document.addEventListener('mouseup', () => {
			endDrag();
		});

		// Hover events for desktop - pause animation on hover
		hitArea.addEventListener('mouseenter', () => {
			dialStates[index].hovered = true;
		});

		hitArea.addEventListener('mouseleave', () => {
			dialStates[index].hovered = false;
		});
	}

	function animate() {
		for (let i = 0; i < DIAL_COUNT; i++) {
			const state = dialStates[i];

			// Skip animation if hovered or currently dragging
			if (state.hovered || state.dragging) continue;

			// Normalize angular speed by radius for consistent linear thumb speed
			// angularSpeed = linearSpeed / radius (converted to degrees)
			const angularSpeed = (state.baseSpeed / state.radius) * (180 / Math.PI);
			state.angle += state.direction * angularSpeed;

			// Normalize to 0-360 (no bouncing at boundaries)
			if (state.angle >= 360) state.angle -= 360;
			if (state.angle < 0) state.angle += 360;

			updateDialRotation(i, state.angle);
		}

		requestAnimationFrame(animate);
	}

	function handleResize() {
		const heroElement = document.querySelector('.hero') as HTMLElement;
		if (!heroElement) return;

		const heroRect = heroElement.getBoundingClientRect();
		const scrollTop = window.scrollY || document.documentElement.scrollTop;
		const heroTopFromPage = heroRect.top + scrollTop;
		const totalHeight = heroElement.offsetHeight + heroTopFromPage;

		// Update container positioning
		const container = document.getElementById('dial-container') as HTMLElement;
		if (container) {
			container.style.top = `-${heroTopFromPage}px`;
			container.style.height = `${totalHeight}px`;
		}

		targetDimensions = { width: window.innerWidth, height: totalHeight };

		if (!resizeFrame) {
			smoothResize();
		}
	}

	function smoothResize() {
		const lerp = (a: number, b: number, t: number) => a + (b - a) * t;

		currentDimensions.width = lerp(currentDimensions.width, targetDimensions.width, 0.15);
		currentDimensions.height = lerp(currentDimensions.height, targetDimensions.height, 0.15);

		updateDialDimensions(currentDimensions.width, currentDimensions.height);

		const widthDiff = Math.abs(currentDimensions.width - targetDimensions.width);
		const heightDiff = Math.abs(currentDimensions.height - targetDimensions.height);

		if (widthDiff > 0.5 || heightDiff > 0.5) {
			resizeFrame = requestAnimationFrame(smoothResize);
		} else {
			resizeFrame = null;
			// Snap to final dimensions
			currentDimensions = { ...targetDimensions };
			updateDialDimensions(targetDimensions.width, targetDimensions.height);
		}
	}

	let animationStarted = false;

	function startAnimation() {
		if (animationStarted) return;
		animationStarted = true;
		animate();
	}

	// Initialize on load
	document.addEventListener('DOMContentLoaded', () => {
		initDials();
		startAnimation();
	});

	// Also initialize immediately if DOM is already loaded
	if (document.readyState !== 'loading') {
		initDials();
		startAnimation();
	}

	// Handle resize
	window.addEventListener('resize', handleResize);
</script>

<style>
	.hero {
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
		min-height: 70vh;
		padding: 4rem 1rem;
		overflow: visible; /* Allow dials to extend beyond */
	}

	/* Dial Container - Absolute positioned, scrolls with page */
	.dial-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		overflow: visible;
		pointer-events: none;
	}

	/* Dial groups - no pointer events on the group itself */
	:global(.dial-group) {
		pointer-events: none;
	}

	/* Hit area - larger invisible touch target */
	:global(.dial-hit-area) {
		pointer-events: auto;
		cursor: grab;
		touch-action: none;
	}

	:global(.dial-hit-area:active) {
		cursor: grabbing;
	}

	/* Thumb visual styling */
	:global(.dial-thumb) {
		pointer-events: none; /* Hit area handles events */
		transition:
			fill 0.2s ease,
			stroke-width 0.2s ease,
			r 0.15s ease;
	}

	/* Hover effect - triggered via hit area hover */
	:global(.dial-hit-area:hover + .dial-thumb),
	:global(.dial-hit-area:hover ~ .dial-thumb) {
		fill: #a3e635;
		stroke-width: 2.5;
		r: 9;
	}

	:global(.dial-thumb.dragging) {
		fill: #a3e635;
		stroke-width: 3;
		r: 10;
	}

	/* Hero Content - allow drag through empty space */
	.hero-content {
		position: relative;
		z-index: 10;
		max-width: 800px;
		width: 100%;
		pointer-events: none; /* Allow drag through empty space */
	}

	/* Re-enable pointer events on actual interactive elements */
	.hero-content h1,
	.hero-content .tagline,
	.hero-content .action-wrapper,
	.hero-content .action-link,
	.hero-content a {
		pointer-events: auto;
	}

	.stack {
		flex-direction: column;
		gap: clamp(1.5rem, calc(1.5rem + 1vw), 2rem);
		text-align: center;
	}

	.copy {
		flex-direction: column;
		gap: 1rem;
		align-items: center;
	}

	.copy > * {
		max-width: 60ch;
	}

	h1 {
		font-size: clamp(var(--sl-text-3xl), calc(0.25rem + 5vw), var(--sl-text-6xl));
		line-height: var(--sl-line-height-headings);
		font-weight: 600;
		color: var(--sl-color-white);
	}

	.tagline {
		font-size: clamp(var(--sl-text-base), calc(0.0625rem + 2vw), var(--sl-text-xl));
		color: var(--sl-color-gray-2);
	}

	.actions {
		gap: 1rem 2rem;
		flex-wrap: wrap;
		justify-content: center;
	}

	/* Primary button wrapper with glow effects */
	.action-wrapper.primary {
		--mouse-x: 50%;
		--mouse-y: 50%;
		--gradient-radius: 100px;
		position: relative;
		border-radius: 14px;
		padding: 1px;
		background: transparent;
		isolation: isolate;
	}

	.action-wrapper.primary::before {
		content: '';
		position: absolute;
		inset: 0;
		border-radius: 14px;
		padding: 1px;
		background: radial-gradient(
			var(--gradient-radius) circle at var(--mouse-x) var(--mouse-y),
			#84cc16 0%,
			#65a30d 40%,
			transparent 80%
		);
		-webkit-mask:
			linear-gradient(#fff 0 0) content-box,
			linear-gradient(#fff 0 0);
		-webkit-mask-composite: xor;
		mask-composite: exclude;
		pointer-events: none;
		opacity: 0.6;
		transition: opacity 0.3s ease;
	}

	.action-wrapper.primary::after {
		content: '';
		position: absolute;
		inset: 1px;
		border-radius: 13px;
		background: radial-gradient(
			var(--gradient-radius) circle at var(--mouse-x) var(--mouse-y),
			rgba(132, 204, 22, 0.25) 0%,
			rgba(132, 204, 22, 0.1) 40%,
			transparent 80%
		);
		pointer-events: none;
		opacity: 0;
		transition: opacity 0.3s ease;
		z-index: 1;
	}

	.action-wrapper.primary:hover::before {
		opacity: 1;
	}

	.action-wrapper.primary:hover::after {
		opacity: 1;
	}

	/* Static border + invisible outer glow (for smooth transition) */
	.action-wrapper.primary {
		box-shadow:
			inset 0 0 0 1px rgba(132, 204, 22, 0.4),
			0 0 25px rgba(132, 204, 22, 0),
			0 0 50px rgba(132, 204, 22, 0),
			0 0 75px rgba(132, 204, 22, 0);
		transition: box-shadow 0.6s ease 0.15s;
	}

	.action-wrapper.primary:hover {
		box-shadow:
			inset 0 0 0 1px rgba(132, 204, 22, 0.4),
			0 0 25px rgba(132, 204, 22, 0.4),
			0 0 50px rgba(132, 204, 22, 0.2),
			0 0 75px rgba(132, 204, 22, 0.1);
	}

	.action-link.primary {
		position: relative;
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.75rem 1.5rem;
		border-radius: 13px;
		background: rgba(132, 204, 22, 0.1);
		color: #bef264;
		font-weight: 600;
		font-size: var(--sl-text-base);
		text-decoration: none;
		z-index: 2;
		transition: all 0.3s ease;
	}

	.action-link.primary:hover {
		color: #ffffff;
		background: rgba(132, 204, 22, 0.15);
	}

	.action-link.primary svg {
		flex-shrink: 0;
	}

	/* Minimal variant */
	.action-wrapper.minimal {
		background: transparent;
	}

	.action-link.minimal {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.75rem 0;
		color: var(--sl-color-gray-2);
		font-size: var(--sl-text-base);
		text-decoration: none;
		transition: color 0.3s ease;
	}

	.action-link.minimal:hover {
		color: var(--sl-color-white);
	}

	.action-link.minimal svg {
		flex-shrink: 0;
	}
</style>
